# 실습 환경 세팅

```shell
$ docker run -d -p 23306:3306 brainbackdoor/data-tuning:0.0.1
```

<br>
<br> 

# 요구 사항

1. 쿼리 작성만으로 1s 이하로 반환한다.  
2. 인덱스 설정을 추가하여 50 ms 이하로 반환한다.  

<br>

> 활동중인(Active) 부서의 현재 부서관리자 중 연봉 상위 5위안에 드는 사람들이 최근에 각 지역별로 언제 퇴실했는지 조회해보세요.
(사원번호, 이름, 연봉, 직급명, 지역, 입출입구분, 입출입시간)

<br>
<br>

# 쿼리 튜닝 과정

### 활동중인 부서의 현재 부서 관리자

```sql
select *
from 부서관리자
join 부서 on 부서관리자.부서번호 = 부서.부서번호 and 부서.비고 = 'active';
```

- 부서관리자에만 부서 번호가 인덱싱 되어있는 상태
- 부서에도 부서번호를 인덱스 걸어준다.

<br>
<br>

### 활동중인 부서의 현재 부서 관리자 중 연봉 상위 5위

```sql
explain
select 부서관리자.사원번호, SUM(급여.연봉) as salary
from 부서관리자
         join 급여 on 부서관리자.사원번호 = 급여.사원번호
where 부서관리자.부서번호 in (select 부서번호 from 부서 where 비고 = 'active')
group by 부서관리자.사원번호
order by salary desc
limit 5;

explain
select 부서관리자.사원번호, SUM(급여.연봉) as salary
from 부서관리자
         join 부서 on 부서관리자.부서번호 = 부서.부서번호 and 부서.비고 = 'active'
         join 급여 on 부서관리자.사원번호 = 급여.사원번호
group by 부서관리자.사원번호
order by salary desc
limit 5;
```

- 다음과 같이 서브 쿼리를 사용한 조회와 join을 사용한 두가지 방식을 사용해보았다.

```sql
select `tuning`.`부서관리자`.`사원번호` AS `사원번호`, sum(`tuning`.`급여`.`연봉`) AS `salary`
from `tuning`.`부서관리자`
         join `tuning`.`부서`
         join `tuning`.`급여`
where ((`tuning`.`부서관리자`.`부서번호` = `tuning`.`부서`.`부서번호`) and (`tuning`.`급여`.`사원번호` = `tuning`.`부서관리자`.`사원번호`) and
       (`tuning`.`부서`.`비고` = 'active'))
group by `tuning`.`부서관리자`.`사원번호`
order by `salary` desc
limit 5;
```

- 하지만 실행 쿼리는 두 방식 모두 위와 같은 쿼리로 나갔다. 즉, 성능적 차이는 없었다.
- 다만 조회 시 부서에서 사용하지 않는 컬럼은 **서브 쿼리의 경우 굳이 가져오지 않는다 정도의 차이가 있었다.**

- 그리고 급여에는 사원 번호에 대한 인덱스가 이미 설정되어있어 별도의 인덱싱을 해주지 않았다.


<br>
<br>

- 그리고 생각해보니 활동중인 부서관리자 (시작일자, 종료일자) 검증도 빼먹음... 😥

```sql
# 1
select 부서관리자.사원번호, SUM(급여.연봉) as salary
from 부서관리자
         join 급여 on 부서관리자.사원번호 = 급여.사원번호 and now() between 급여.시작일자 and 급여.종료일자
where 부서관리자.부서번호 in (select 부서번호 from 부서 where 비고 = 'active') and now() between 부서관리자.시작일자 and 부서관리자.종료일자
group by 부서관리자.사원번호
order by salary desc
limit 5;

# 2
select 부서관리자.사원번호, SUM(급여.연봉) as salary
from 부서관리자
         join 부서 on 부서관리자.부서번호 = 부서.부서번호 and 부서.비고 = 'active'
         join 급여 on 부서관리자.사원번호 = 급여.사원번호 and now() between 급여.시작일자 and 급여.종료일자
where now() between 부서관리자.시작일자 and 부서관리자.종료일자
group by 부서관리자.사원번호
order by salary desc
limit 5;
```


## 모든 조건을 적용

```sql
# 1
select 사원.사원번호, 사원.이름, top5.salary, 직급.직급명
from 사원
         join (
    select 부서관리자.사원번호, SUM(급여.연봉) as salary
    from 부서관리자
             join 급여 on 부서관리자.사원번호 = 급여.사원번호 and now() between 급여.시작일자 and 급여.종료일자
    where 부서관리자.부서번호 in (select 부서번호 from 부서 where 비고 = 'active')
      and now() between 부서관리자.시작일자 and 부서관리자.종료일자
    group by 부서관리자.사원번호
    order by salary desc
    limit 5
) top5 on top5.사원번호 = 사원.사원번호
         join 직급 on 사원.사원번호 = 직급.사원번호 and now() between 직급.시작일자 and 직급.종료일자
         join 사원출입기록 on 사원.사원번호 = 사원출입기록.사원번호 and 사원출입기록.입출입구분 = 'O';

# 2
select 사원.사원번호, 사원.이름, top5.연봉, 직급.직급명, 사원출입기록.지역, 사원출입기록.입출입구분
from 사원
         join (
    select 부서관리자.사원번호, SUM(급여.연봉) as 연봉
    from 부서관리자
             join 부서 on 부서관리자.부서번호 = 부서.부서번호 and 부서.비고 = 'active'
             join 급여 on 부서관리자.사원번호 = 급여.사원번호 and now() between 급여.시작일자 and 급여.종료일자
    where now() between 부서관리자.시작일자 and 부서관리자.종료일자
    group by 부서관리자.사원번호
    order by 연봉 desc
    limit 5
) top5 on top5.사원번호 = 사원.사원번호
         join 직급 on 사원.사원번호 = 직급.사원번호 and now() between 직급.시작일자 and 직급.종료일자
         join 사원출입기록 on 사원.사원번호 = 사원출입기록.사원번호 and 사원출입기록.입출입구분 = 'O';

# 실행시간
[2021-11-21 16:22:02] 14 rows retrieved starting from 1 in 301 ms (execution: 289 ms, fetching: 12 ms)
```

- 실행 계획

    | id | select\_type | table | partitions | type | possible\_keys | key | key\_len | ref | rows | filtered | Extra |
    | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- |
    | 1 | PRIMARY | &lt;derived2&gt; | NULL | ALL | NULL | NULL | NULL | NULL | 2 | 100 | NULL |
    | 1 | PRIMARY | 직급 | NULL | ref | PRIMARY | PRIMARY | 4 | top5.사원번호 | 1 | 11.11 | Using where |
    | 1 | PRIMARY | 사원 | NULL | eq\_ref | PRIMARY | PRIMARY | 4 | top5.사원번호 | 1 | 100 | NULL |
    | 1 | PRIMARY | 사원출입기록 | NULL | ALL | NULL | NULL | NULL | NULL | 658935 | 1 | Using where; Using join buffer \(Block Nested Loop\) |
    | 2 | DERIVED | 부서 | NULL | ALL | PRIMARY,I\_부서번호 | NULL | NULL | NULL | 9 | 11.11 | Using where; Using temporary; Using filesort |
    | 2 | DERIVED | 부서관리자 | NULL | ref | PRIMARY,I\_부서번호 | I\_부서번호 | 12 | tuning.부서.부서번호 | 2 | 11.11 | Using where |
    | 2 | DERIVED | 급여 | NULL | ref | PRIMARY | PRIMARY | 4 | tuning.부서관리자.사원번호 | 9 | 11.11 | Using where |

    - 사원출입기록에서 658935 rows가 조회되는 것을 확인할 수 있다. 사원출입기록.사원번호에 인덱스를 걸어 좀 더 빠르게 데이터에 접근하도록 설정해보자.

<br>

```sql
# 실행 결과
[2021-11-21 16:25:43] 14 rows retrieved starting from 1 in 23 ms (execution: 7 ms, fetching: 16 ms)
```

- 실행 계획

    | id | select\_type | table | partitions | type | possible\_keys | key | key\_len | ref | rows | filtered | Extra |
    | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- |
    | 1 | PRIMARY | &lt;derived2&gt; | NULL | ALL | NULL | NULL | NULL | NULL | 2 | 100 | NULL |
    | 1 | PRIMARY | 직급 | NULL | ref | PRIMARY | PRIMARY | 4 | top5.사원번호 | 1 | 11.11 | Using where |
    | 1 | PRIMARY | 사원출입기록 | NULL | ref | I\_사원번호 | I\_사원번호 | 4 | top5.사원번호 | 4 | 10 | Using where |
    | 1 | PRIMARY | 사원 | NULL | eq\_ref | PRIMARY | PRIMARY | 4 | top5.사원번호 | 1 | 100 | NULL |
    | 2 | DERIVED | 부서 | NULL | ALL | PRIMARY,I\_부서번호 | NULL | NULL | NULL | 9 | 11.11 | Using where; Using temporary; Using filesort |
    | 2 | DERIVED | 부서관리자 | NULL | ref | PRIMARY,I\_부서번호 | I\_부서번호 | 12 | tuning.부서.부서번호 | 2 | 11.11 | Using where |
    | 2 | DERIVED | 급여 | NULL | ref | PRIMARY | PRIMARY | 4 | tuning.부서관리자.사원번호 | 9 | 11.11 | Using where |

    - 사원 출입기록이 인덱스로 설정되면서 4 rows로 변경되어 빠르게 찾아오게 된 것을 확인
    
