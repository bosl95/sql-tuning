# 요구 사항

> 프로그래밍이 취미인 학생 혹은 주니어(0-2년)들이 다닌 병원 이름을 반환하고 user.id 기준으로 정렬하세요. (covid.id, hospital.name, user.Hobby, user.DevType, user.YearsCoding)

<br>


- 프로그래밍이 취미인 학생 혹은 주니어(0-2년)들

```sql
select p.id
from programmer as p
where p.years_coding like '0-2%' or (p.hobby = 'yes' and p.student like 'yes%');

# 27488 rows (원래 총 98855)
```

<br>

```sql
# 1
select 조건을_만족한_프로그래머.id, filter_c.name
from (
         select p.id
         from programmer as p
         where p.years_coding like '0-2%'
            or (p.hobby = 'yes' and p.student like 'yes%')
     ) as 조건을_만족한_프로그래머
         join (select c.programmer_id, h.name
               from covid as c
                        join hospital h on c.hospital_id = h.id) as filter_c
              on filter_c.programmer_id = 조건을_만족한_프로그래머.id;

# 실행결과 
[2021-11-21 17:56:40] 500 rows retrieved starting from 1 in 5 s 784 ms (execution: 5 s 772 ms, fetching: 12 ms)


# 2
select p.id, c.name
from programmer as p
         join (select c.programmer_id, h.name
               from covid as c
                        join hospital h on c.hospital_id = h.id
        ) c on p.id = c.programmer_id
where p.years_coding like '0-2%' or (p.hobby = 'yes' and p.student like 'yes%');
# 실행결과
[2021-11-21 17:55:12] 500 rows retrieved starting from 1 in 5 s 898 ms (execution: 5 s 887 ms, fetching: 11 ms)

```

- 드라이븐 테이블에 들어갈 데이터를 최대한 적게 가져가보면 어떨까 싶어 "조건을 만족한 프로그래머"로 실행해보았으나 그냥 join을 한 결과와 동일한 실행 계획이 나왔다.  
  

  
| id | select\_type | table | partitions | type | possible\_keys | key | key\_len | ref | rows | filtered | Extra |
| :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- |
| 1 | SIMPLE | p | NULL | ALL | NULL | NULL | NULL | NULL | 71210 | 12.1 | Using where |
| 1 | SIMPLE | c | NULL | ALL | I\_hospital\_id | NULL | NULL | NULL | 315397 | 10 | Using where; Using join buffer \(Block Nested Loop\) |
| 1 | SIMPLE | h | NULL | ref | I\_id | I\_id | 5 | subway.c.hospital\_id | 1 | 100 | Using index condition |

<br>
<br>

- programmer(id) 와 covid (id, programmer_id) 를 각각 인덱싱 해주자.

```sql
# 실행 결과
[2021-11-21 19:58:54] 500 rows retrieved starting from 1 in 50 ms (execution: 19 ms, fetching: 31 ms)
```

| id | select\_type | table | partitions | type | possible\_keys | key | key\_len | ref | rows | filtered | Extra |
| :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- |
| 1 | SIMPLE | c | NULL | index | NULL | I\_id\_programmer\_id\_hospital\_id | 27 | NULL | 315397 | 100 | Using where; Using index |
| 1 | SIMPLE | h | NULL | ref | I\_id | I\_id | 5 | subway.c.hospital\_id | 1 | 100 | Using index condition |
| 1 | SIMPLE | p | NULL | ref | I\_id\_hobby | I\_id\_hobby | 9 | subway.c.programmer\_id | 1 | 12.1 | Using where |

- (인덱스에 뭐가 있는 지 알기 쉽게 이름을 수정했다.)
- 대략 5s => 19ms까지 속도가 빨라진 것을 확인할 수 있었다.

<br>
<br>

- 그 와중에 또 취미가 프로그래밍인 학생 또는 주니어라고 해서 `(취미가 프로그래밍인 학생) or (주니어)` 이렇게 해석했는데, `취미가 프로그래밍인 학생 or 취미가 프로그래밍인 주니어`인 거 같아서 쿼리를 바꿔보았다.

```sql
# 1
subway> select 조건을_만족한_프로그래머.id, filter_c.name
        from (
                 select p.id
                 from programmer as p
                 where p.hobby = 'yes'
                    and ( p.student like 'yes%' or p.years_coding like '0-2%')
             ) as 조건을_만족한_프로그래머
                 join (select c.programmer_id, h.name
                       from covid as c
                                join hospital h on c.hospital_id = h.id) as filter_c
                      on filter_c.programmer_id = 조건을_만족한_프로그래머.id
[2021-11-21 20:08:18] 500 rows retrieved starting from 1 in 32 ms (execution: 19 ms, fetching: 13 ms)

# 2
subway> select p.id, c.name
        from programmer as p
                 join (select c.programmer_id, h.name
                       from covid as c
                                join hospital h on c.hospital_id = h.id
        ) c on p.id = c.programmer_id
        where p.hobby = 'yes'
           and (p.years_coding like '0-2%' or p.student like 'yes%')
[2021-11-21 20:08:33] 500 rows retrieved starting from 1 in 32 ms (execution: 19 ms, fetching: 13 ms)
```