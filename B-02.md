# 요구 사항


> 프로그래머별로 해당하는 병원 이름을 반환하세요. (covid.id, hospital.name)


```sql
select c.programmer_id, h.name
from covid as c
join hospital h on h.id = c.hospital_id
where c.programmer_id is not null;

# 실행 결과
[2021-11-21 17:12:54] 500 rows retrieved starting from 1 in 20 ms (execution: 7 ms, fetching: 13 ms)
```

- 실행 계획

    | id | select\_type | table | partitions | type | possible\_keys | key | key\_len | ref | rows | filtered | Extra |
    | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- |
    | 1 | SIMPLE | h | NULL | ALL | NULL | NULL | NULL | NULL | 32 | 100 | NULL |
    | 1 | SIMPLE | c | NULL | ALL | NULL | NULL | NULL | NULL | 315397 | 9 | Using where; Using join buffer \(Block Nested Loop\) |

<br>
<br>

- covid와 hospital에 hospital id에 인덱스를 걸어보자. (hospital의 경우 unique 지정)

```sql
# 실행결과
[2021-11-21 17:17:23] 500 rows retrieved starting from 1 in 18 ms (execution: 8 ms, fetching: 10 ms)
```

- 실행 계획

    | id | select\_type | table | partitions | type | possible\_keys | key | key\_len | ref | rows | filtered | Extra |
    | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- |
    | 1 | SIMPLE | h | NULL | ALL | I\_id | NULL | NULL | NULL | 32 | 100 | Using where |
    | 1 | SIMPLE | c | NULL | ref | I\_hospital\_id | I\_hospital\_id | 9 | subway.h.id | 10174 | 90 | Using index condition; Using where |

  - 실행 결과에는 큰 차이가 없었으나, 실행 계획의 경우 covid에서 315397 rows가 조회되던 부분이 9개만 조회되는 방식으로 바뀌는 것을 확인할 수 있었다.

